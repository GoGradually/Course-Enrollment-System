# k6 실행 가이드

## 1. 사전 조건

- JDK 21
- `k6`
- `curl`
- `jq`

## 2. 기본 원칙

- 시나리오는 **한 번에 하나씩** 실행한다.
- 서버는 원하는 격리수준 프로파일로 먼저 기동한다.
- 전략 비교(SQL 직접 사용(atomic) vs 트랜잭션 분리(separated))는 **시나리오마다 서버를 재기동**해 동일 초기 상태에서 수행한다.
- `SUMMARY_PATH` 미지정 시 단일은 `performance/k6/results/single`, 멀티는 `performance/k6/results/multi`에 자동 저장된다.
- 필요 시 `SUMMARY_PATH`로 저장 경로를 직접 지정할 수 있다.

## 3. 서버 실행

READ COMMITTED:

```bash
SPRING_PROFILES_ACTIVE=read-committed ./gradlew bootRun
```

REPEATABLE READ:

```bash
SPRING_PROFILES_ACTIVE=repeatable-read ./gradlew bootRun
```

## 4. 실행 환경

디스크 I/O 기준으로 판단하기 위해 docker mysql 이미지 사용:

```bash
docker run -d --name mysql-test \
  -e MYSQL_ROOT_PASSWORD=pass \
  -p 3307:3306 \
  mysql:8
```

## 5. 시나리오 파일

#### 단일 핫코스

- `performance/k6/scenarios/rc-pessimistic.js`
- `performance/k6/scenarios/rc-optimistic.js`
- `performance/k6/scenarios/rc-atomic.js` (`/enrollments/atomic`, SQL 직접 사용)
- `performance/k6/scenarios/rc-separated.js` (`/enrollments/separated`, 트랜잭션 분리)
- `performance/k6/scenarios/rr-pessimistic.js`
- `performance/k6/scenarios/rr-optimistic.js`
- `performance/k6/scenarios/rr-atomic.js` (`/enrollments/atomic`, SQL 직접 사용)
- `performance/k6/scenarios/rr-separated.js` (`/enrollments/separated`, 트랜잭션 분리)

#### 멀티코스 경쟁

- `performance/k6/scenarios/rc-atomic-multi.js` (`/enrollments/atomic`, SQL 직접 사용)
- `performance/k6/scenarios/rc-separated-multi.js` (`/enrollments/separated`, 트랜잭션 분리)
- `performance/k6/scenarios/rr-atomic-multi.js` (`/enrollments/atomic`, SQL 직접 사용)
- `performance/k6/scenarios/rr-separated-multi.js` (`/enrollments/separated`, 트랜잭션 분리)

## 6. 단일 시나리오 실행 예시

```bash
BASE_URL=http://localhost:8080 \
VUS=1000 \
LOOPS=1 \
RAMP_UP_SECONDS=5 \
P95_MS=1000 \
FAIL_ON_ASSERTION=true \
SUMMARY_PATH=performance/k6/results/single/rc-atomic.summary.json \
k6 run performance/k6/scenarios/rc-atomic.js
```

## 7. 멀티 시나리오 실행 예시 (50개 과목 x 정원 3배)

```bash
BASE_URL=http://localhost:8080 \
VUS=1000 \
RAMP_UP_SECONDS=5 \
P95_MS=1000 \
FAIL_ON_ASSERTION=true \
MULTI_COURSE_COUNT=50 \
MULTI_COMPETITION_MULTIPLIER=3 \
MULTI_MAX_TOTAL_ATTEMPTS=10000 \
MULTI_INTERLEAVE_SEED=20260222 \
MULTI_REQUIRE_EMPTY_ENROLLED=true \
SUMMARY_PATH=performance/k6/results/multi/rc-atomic-multi.summary.json \
k6 run performance/k6/scenarios/rc-atomic-multi.js
```

## 8. SQL 직접 사용(atomic) vs 트랜잭션 분리(separated) 비교 절차 (RC + RR)

### 8.1 READ COMMITTED

1. 서버 기동: `SPRING_PROFILES_ACTIVE=read-committed ./gradlew bootRun`
2. `rc-atomic-multi` 실행 후 결과 저장 (`/enrollments/atomic`)
3. 서버 중지 후 재기동(같은 프로파일)
4. `rc-separated-multi` 실행 후 결과 저장 (`/enrollments/separated`)
5. 비교:

```bash
scripts/compare-k6-summary.sh \
  performance/k6/results/multi/rc-atomic-multi.summary.json \
  performance/k6/results/multi/rc-separated-multi.summary.json \
  rc-atomic rc-separated
```

### 8.2 REPEATABLE READ

1. 서버 기동: `SPRING_PROFILES_ACTIVE=repeatable-read ./gradlew bootRun`
2. `rr-atomic-multi` 실행 후 결과 저장 (`/enrollments/atomic`)
3. 서버 중지 후 재기동(같은 프로파일)
4. `rr-separated-multi` 실행 후 결과 저장 (`/enrollments/separated`)
5. 비교:

```bash
scripts/compare-k6-summary.sh \
  performance/k6/results/multi/rr-atomic-multi.summary.json \
  performance/k6/results/multi/rr-separated-multi.summary.json \
  rr-atomic rr-separated
```

## 9. 런타임 데이터 준비 규칙

단일 핫코스:

- `HOT_COURSE_ID` 미지정 시 `TARGET_CAPACITY`(기본 100), `enrolled=0` 조건의 강좌를 자동 선택
- 필요한 학생 수(`VUS * LOOPS`)만큼 `/students`에서 고유 ID 수집

멀티코스:

- `/courses`에서 후보 강좌를 수집하고(기본 `enrolled=0`), ID 오름차순으로 `MULTI_COURSE_COUNT`개 선택
- 과목별 요청 수는 `capacity * MULTI_COMPETITION_MULTIPLIER`로 계산
- 전체 요청 계획(`plannedAttempts`)만큼 고유 학생 ID를 `/students`에서 수집
- 요청 목록을 시드(`MULTI_INTERLEAVE_SEED`) 기반으로 셔플해 랜덤 인터리브
- `plannedAttempts > MULTI_MAX_TOTAL_ATTEMPTS`면 setup 단계에서 실패

## 10. 환경 변수

공통:

- `BASE_URL` (기본: `http://localhost:8080`)
- `VUS` (기본: `1000`)
- `RAMP_UP_SECONDS` (기본: `5`)
- `P95_MS` (기본: `1000`)
- `MAX_DURATION` (단일 기본: `2m`, 멀티 기본: `5m`)
- `FAIL_ON_ASSERTION` (기본: `false`)
- `SUMMARY_PATH` (선택, 미지정 시 단일: `performance/k6/results/single/<scenario>.summary.json`, 멀티:
  `performance/k6/results/multi/<scenario>.summary.json`)

단일 전용:

- `LOOPS` (기본: `1`)
- `HOT_COURSE_ID` (선택)
- `TARGET_CAPACITY` (기본: `100`)

멀티 전용:

- `MULTI_COURSE_COUNT` (기본: `50`)
- `MULTI_COMPETITION_MULTIPLIER` (기본: `3`)
- `MULTI_MAX_TOTAL_ATTEMPTS` (기본: `10000`)
- `MULTI_INTERLEAVE_SEED` (기본: `20260222`)
- `MULTI_REQUIRE_EMPTY_ENROLLED` (기본: `true`)

## 11. 핵심 지표

- 성공률: `201 / total`
- 충돌률: `409 / total`
- 규칙위반률: `422 / total`
- 지연시간: avg/med/max/p95/p99
- Throughput(req/s)
- 도메인 불변식:
  - 단일: `requestCountMatched`, `capacityNotExceeded`
  - 멀티: `attemptsMatchedPlan`, `allCoursesWithinCapacity`

## 12. Pass/Fail 기준

공통:

- `201/409/422` 외 코드가 있으면 실패
- 지연시간 p95가 `P95_MS` 초과면 실패

단일:

- `attempts == VUS * LOOPS` 이어야 함
- `FAIL_ON_ASSERTION=true`일 때 최종 `enrolled <= capacity` 위반 시 실패

멀티:

- `attempts == workload.plannedAttempts` 이어야 함
- `FAIL_ON_ASSERTION=true`일 때 선택한 모든 과목에서 `enrolled <= capacity` 위반 시 실패

## 13. 결과 파일

단일 요약 계산 기준:

- `performance/k6/lib/summary.js`
- `performance/k6/lib/config.js`

멀티 요약 계산 기준:

- `performance/k6/lib/multi-summary.js`
- `performance/k6/lib/multi-config.js`
- `performance/k6/lib/multi-domain-assertion.js`

멀티 summary 예시:

```json
{
  "scenario": "rc-atomic-multi",
  "workload": {
    "courseCount": 50,
    "competitionMultiplier": 3,
    "plannedAttempts": 6000,
    "maxConfiguredAttempts": 10000,
    "totalCapacity": 2000,
    "totalEnrolledFinal": 2000
  },
  "totals": {
    "total": 6000,
    "attempts": 6000,
    "status201": 2000,
    "status409": 0,
    "status422": 4000,
    "unexpected": 0,
    "unexpectedByStatus": {}
  },
  "latencyMs": {
    "avg": 10.2,
    "med": 2.1,
    "max": 140.7,
    "p95": 52.6,
    "p99": 110.3
  },
  "throughputRps": 450.1,
  "domainAssertions": {
    "allowedCodesOnly": true,
    "noUnexpectedStatus": true,
    "attemptsMatchedPlan": true,
    "allCoursesWithinCapacity": true,
    "pass": true
  }
}
```

## 14. 결과 비교 도구

```bash
scripts/compare-k6-summary.sh <atomic_summary.json> <separated_summary.json> [atomic_label] [separated_label]
```

예시:

```bash
scripts/compare-k6-summary.sh \
  performance/k6/results/multi/rc-atomic-multi.summary.json \
  performance/k6/results/multi/rc-separated-multi.summary.json \
  rc-atomic rc-separated
```

출력 항목:

- attempts, `201/409/422`, unexpected
- p95(ms), throughput(req/s)
- `domainAssertions.pass`
- separated-atomic delta (`p95_delta_ms`, `throughput_delta_rps`)

참고:

- 본 문서의 `atomic`은 **SQL 직접 사용 전략**을 의미한다 (`POST /enrollments/atomic`).
- 본 문서의 `separated`는 **트랜잭션 분리 전략**을 의미한다 (`POST /enrollments/separated`).

## 15. 반복 가능 실행 자동화 (권장)

아래 스크립트는 멀티 4종 시나리오를 기본으로 **각 run마다 서버 재기동** 후 k6를 실행하고, 자동으로 집계/비교까지 수행한다.

```bash
VUS=1000 \
RAMP_UP_SECONDS=5 \
P95_MS=1000 \
FAIL_ON_ASSERTION=true \
MULTI_COURSE_COUNT=50 \
MULTI_COMPETITION_MULTIPLIER=3 \
MULTI_MAX_TOTAL_ATTEMPTS=10000 \
MULTI_INTERLEAVE_SEED=20260222 \
MULTI_REQUIRE_EMPTY_ENROLLED=true \
scripts/run-k6-repeatable.sh
```

주요 옵션:

- `--runs` (기본: `25`)
- `--profiles` (기본: `read-committed,repeatable-read`)
- `--scenarios` (기본: `rc-atomic-multi,rc-separated-multi,rr-atomic-multi,rr-separated-multi`)
- `--cv-threshold` (기본: `0.10`)
- `--fail-on-thresholds` (기본: `false`, `true`로 주면 threshold 초과 시 즉시 실패)
- `--base-url` (기본: `http://localhost:8080`)
- `--stabilize-seconds` (기본: `10`)
- `--health-timeout-seconds` (기본: `120`)
- `--result-root` (기본: `performance/k6/results/repeatable`)

readiness 체크 기준:

- `/health`가 `200`
- `/courses?offset=0&limit=1`가 `200`이며 non-empty 배열 반환

주의:

- `k6`를 snap으로 설치한 환경에서는 `/tmp` 경로에 summary 파일 쓰기가 실패할 수 있다.
- 이 경우 `--result-root`를 저장소 내부 경로로 지정한다.

예시 (`read-committed` 2개 시나리오만 5회 반복):

```bash
scripts/run-k6-repeatable.sh \
  --runs 5 \
  --profiles read-committed \
  --scenarios rc-atomic-multi,rc-separated-multi
```

## 16. 반복 실행 결과 경로

- raw summary: `performance/k6/results/repeatable/raw/<profile>/<scenario>/run-XX.summary.json`
- run 메타: `performance/k6/results/repeatable/raw/<profile>/<scenario>/run-XX.meta.json`
- 서버 로그: `performance/k6/results/repeatable/logs/<profile>/<scenario>/run-XX.server.log`
- 집계 결과: `performance/k6/results/repeatable/aggregated/<profile>/<scenario>.aggregate.json`
- 전략 비교: `performance/k6/results/repeatable/comparison/<profile>-atomic-vs-separated.aggregate.json`

## 17. 안정성 판정 규칙 (중앙값 + IQR + CV)

`scripts/aggregate-k6-runs.sh`는 각 지표에 대해 `mean`, `median`, `q1`, `q3`, `iqr`, `stddev`, `cv`를 계산한다.

기본 안정성(`stability.pass`) 판정:

- 모든 run에서 `domainAssertions.pass == true`
- 모든 run에서 요청 수 일치 (`attemptsMatchedAll == true`)
- `latencyMs.p95`의 `cv <= 0.10`
- `throughputRps`의 `cv <= 0.10`

해석 가이드:

- 대표값은 `median` 사용
- 변동폭은 `iqr` 우선 확인
- 환경 노이즈 감시는 `cv`로 관리

## 18. 집계/집계비교 도구

개별 시나리오 반복 결과 집계:

```bash
scripts/aggregate-k6-runs.sh \
  --input-dir performance/k6/results/repeatable/raw/read-committed/rc-atomic-multi \
  --output performance/k6/results/repeatable/aggregated/read-committed/rc-atomic-multi.aggregate.json \
  --cv-threshold 0.10
```

집계 결과 비교 (separated - atomic, median 기준 delta):

```bash
scripts/compare-k6-aggregate.sh \
  performance/k6/results/repeatable/aggregated/read-committed/rc-atomic-multi.aggregate.json \
  performance/k6/results/repeatable/aggregated/read-committed/rc-separated-multi.aggregate.json \
  rc-atomic rc-separated \
  performance/k6/results/repeatable/comparison/read-committed-atomic-vs-separated.aggregate.json
```

## 19. Matplotlib 시각화 (RC/RR 통합)

반복 집계 결과(`aggregated`)를 기반으로 `RC`/`RR`를 한 장에서 비교할 수 있다.

- 좌측 subplot: `latency p95 (ms)`
- 우측 subplot: `throughput (req/s)`
- 비교 그룹: `RC Atomic`, `RC Separated`, `RR Atomic`, `RR Separated`

사전 준비:

```bash
python3 -m pip install matplotlib
```

실행:

```bash
python3 scripts/plot-repeatable-comparison.py
```

출력 파일(기본):

- `performance/k6/results/repeatable/plots/repeatable-rc-rr-atomic-vs-separated.png`

옵션 예시:

```bash
python3 scripts/plot-repeatable-comparison.py \
  --root performance/k6/results/repeatable/aggregated \
  --output performance/k6/results/repeatable/plots/custom-compare.png \
  --dpi 200
```
